
@InProceedings{TLSF,
    author={Masmano, M. and Ripoll, I. and Crespo, A. and Real, J.},
    booktitle={Proceedings. 16th Euromicro Conference on Real-Time Systems, 2004. ECRTS 2004.}, 
    title={{TLSF}: a new dynamic memory allocator for real-time systems}, 
    year={2004},
    pages={79-88},
    doi={10.1109/EMRTS.2004.1311009}
}

@article{zgc_deep_dive,
    author = {Yang, Albert Mingkun and Wrigstad, Tobias},
    title = {Deep Dive into ZGC: A Modern Garbage Collector in OpenJDK},
    year = {2022},
    issue_date = {December 2022},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {44},
    number = {4},
    issn = {0164-0925},
    url = {https://doi.org/10.1145/3538532},
    doi = {10.1145/3538532},
    abstract = {ZGC is a modern, non-generational, region-based, mostly concurrent, parallel, mark-evacuate collector recently added to OpenJDK. It aims at having GC pauses that do not grow as the heap size increases, offering low latency even with large heap sizes. The ZGC C++ source code is readily accessible in the OpenJDK repository, but reading it (25 KLOC) can be very intimidating, and one might easily get lost in low-level implementation details, obscuring the key concepts. To make the ZGC algorithm more approachable, this work provides a thorough description on a high-level, focusing on the overall design with moderate implementation details. To explain the concurrency aspects, we provide a SPIN model that allows studying races between mutators and GC threads, and how they are resolved in ZGC. Such a model is not only useful for learning the current design (offering a deterministic and interactive experience) but also beneficial for prototyping new ideas and extensions. Our hope is that our detailed description and the SPIN model will enable the use of ZGC as a building block for future GC research, and research ideas implemented on top of it could even be adopted in the industry more readily, bridging the gap between academia and industry in the context of GC research.},
    journal = {ACM Trans. Program. Lang. Syst.},
    month = {sep},
}

@inproceedings{zpage_size_table,
    author = {Yang, Albert Mingkun and \"{O}sterlund, Erik and Wrigstad, Tobias},
    title = {Improving program locality in the GC using hotness},
    year = {2020},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3385412.3385977},
    doi = {10.1145/3385412.3385977},
    pages = {301â€“313},
}

@book{gchandbook,
    title={The Garbage Collection Handbook: The Art of Automatic Memory Management},
    author={Jones, Richard and Hosking, Antony and Moss, Eliot},
    year={2016},
    publisher={Chapman and Hall/CRC}
}

@article{dlmalloc,
    author = {Lea, Doug},
    title = {{A} {M}emory {A}llocator},
    journal = {Unix/Mail},
    month = "6",
    year = "1996"
}

@online{lilliput,
    author = {{OpenJDK}},
    title = {{Lilliput Wiki}},
    year = {2024},
    url = {https://wiki.openjdk.org/display/lilliput/Main},
    note = {Accessed: March 5, 2024}
}

@book{artofmpprogramming,
    author = {Herlihy, Maurice and Shavit, Nir},
    title = {The Art of Multiprocessor Programming, Revised Reprint},
    year = {2012},
    isbn = {9780123973375},
    publisher = {Morgan Kaufmann Publishers Inc.},
    address = {San Francisco, CA, USA},
    edition = {1st},
    abstract = {Revised and updated with improvements conceived in parallel programming courses, The Art of Multiprocessor Programming is an authoritative guide to multicore programming. It introduces a higher level set of software development skills than that needed for efficient single-core programming. This book provides comprehensive coverage of the new principles, algorithms, and tools necessary for effective multiprocessor programming. Students and professionals alike will benefit from thorough coverage of key multiprocessor programming issues. This revised edition incorporates much-demanded updates throughout the book, based on feedback and corrections reported from classrooms since 2008 Learn the fundamentals of programming multiple threads accessing shared memory Explore mainstream concurrent data structures and the key elements of their design, as well as synchronization techniques from simple locks to transactional memory systems Visit the companion site and download source code, example Java programs, and materials to support and enhance the learning experience Table of Contents 1. Introduction 2. Mutual Exclusion 3. Concurrent Objects and Linearization 4. Foundations of Shared Memory 5. The Relative Power of Synchronization Methods 6. The Universality of Consensus 7. Spin Locks and Contention 8. Monitors and Blocking Synchronization 9. Linked Lists: the Role of Locking 10. Concurrent Queues and the ABA Problem 11. Concurrent Stacks and Elimination 12. Counting, Sorting and Distributed Coordination 13. Concurrent Hashing and Natural Parallelism 14. Skiplists and Balanced Search 15. Priority Queues 16. Futures, Scheduling and Work Distribution 17. Barriers 18. Transactional Memory Appendices}
}

@InProceedings{bjarne_aba,
    author={Dechev, Damian and Pirkelbauer, Peter and Stroustrup, Bjarne},
    booktitle={2010 13th IEEE International Symposium on Object/Component/Service-Oriented Real-Time Distributed Computing}, 
    title={Understanding and Effectively Preventing the ABA Problem in Descriptor-Based Lock-Free Designs}, 
    year={2010},
    volume={},
    number={},
    pages={185-192},
    doi={10.1109/ISORC.2010.10}
}
