
ZGC is a region-based garbage collector, which allocates objects inside units of memory that are referred to as pages in ZGC. New objects are allocated inside pages with respect to their size. Pages are classified as one of the three different types: \textit{Small}, \textit{Medium} or \textit{Large}, which support allocations of different size ranges, as specified in Table~\ref{table:zpage_sizes}. All allocations are aligned to 8 bytes and the smallest supported allocation size is, at the time of writing, 16 bytes. As a result of all allocations having the same alignment, their offset from the start of the page will also be a multiple of the alignment.

\begin{table}[H]
    \centering
    \begin{tabular}{lllll}
        Page Type   & Page Size     & \multicolumn{3}{l}{Object Size}      \\ \hline
        Small       & 2 MB          & \multicolumn{3}{l}{{[}16B, 256KB{]}} \\
        Medium      & 32 MB         & \multicolumn{3}{l}{(256KB, 4MB)}     \\
        Large       & $\geq$ 4 MB   & \multicolumn{3}{l}{$\geq$ 4MB}       \\
    \end{tabular}
    \caption{Page sizes in ZGC. (Figure taken from~\cite{zpage_size_table}). }
    \label{table:zpage_sizes}
\end{table}

Pages in ZGC keep track of information that allow them to efficiently allocate new memory and work concurrently with multiple threads. An overview of this information is shown in Figure~\ref{fig:zpages}, where the most important attributes are the: \textit{Bump Pointer}, \textit{Live Map}, \textit{Sequence Number}, and \textit{Age}, which are explained in detail below.

\begin{description}
    \item[Bump Pointer]
        The bump pointer points to the location where new allocations are made inside the page. Its functionality and use-case is explained in greated detail in Section~\ref{sec:bump_pointer}. All allocations inside pages in ZGC are currently done using bump pointers.

    \item[Live Map]
        The live map is used to keep track of which objects are currently live and have been marked as reachable by the program. Objects not marked in the live map are considered dead and can be reclaimed by the GC. The live map is illustrated on the right-hand side of Figure~\ref{fig:zpages}. It is constructed during the marking phase of the GC cycle as live objects are encountered during memory traversal and stored in a bitmap. Each bit is mapped to an 8 byte chunk of the page and if a bit is set, there is a live object at the corresponding place in the page. The data collected in the live map is later used during the compacting phase, which will contain knowledge about what objects can be reclaimed.

        \newpage
    \item[Sequence Number]
        Every page has a sequence number denoting during which GC cycle it was created. New allocations are exclusively done in pages created after the latest GC cycle. Pages which created before the current GC cycle are therefore separated from new ones, allowing the GC to work concurrently while the program is executing. For example, if the current Java program has performed 5 GC cycles, any allocations after that will be exclusively done on pages with sequence number 5. If the program decides to run a 6th cycle, only garbage from pages with sequence number 0 through 5 will be collected, and new allocations are done on pages with sequence number 6.

    \item[Age]
        ZGC is a generational garbage collector, meaning it treats objects of varying age differently to improve performance. This is based on the observation that most objects survive for only a short period of time and those that survive for longer tend to live for a long time. ZGC applies this approach on a page-by-page basis, where all allocations on a page share the same age, which is conveniently stored on each page instead for every object. Objects are grouped into three different age categories: \textit{Eden}, \textit{Survivor} and \textit{Old}. The \textit{Eden} age is for first-time allocation, \textit{Survivor} signifies objects that have survived one or more GC cycles and \textit{Old} those that have survived a threshold of cycles in the \textit{Survivor} age. Classifying pages this way allows the GC to treat pages of a certain age differently, which is especially useful for \textit{Eden} pages, which tend to accumulate garbage quickly.
\end{description}

\begin{figure}[H]
    \centering
    \includesvg[scale=0.8]{figures/zpage_withage.svg}
    \caption{Illustration of a page in ZGC showing what kind of metadata is kept track of to facilitate allocation and object bookkeeping. The page contains three live objects marked in green and with the corresponding bit set in the live map to the right.} 
    \label{fig:zpages}
\end{figure}

\subsubsection{The Garbage Collection Cycle}

Figure~\ref{fig:zgc_timeline} shows a timeline of a garbage collection cycle in ZGC, made up of an example heap and pages. The timeline shows the different phases of a cycle and how the garbage collector prepares for relocating memory to free unused memory. The three different steps in the timeline show:

\vspace*{-0.4cm}

\begin{enumerate}[label=\alph*)]
    \item The initial state of the heap before the first GC cycle. The left page has about 30\% free memory and the right page has about 50\%. The current cycle is 1, as shown by the digit on the top left of each page.
    \item The GC cycle has started, and the old pages have been frozen. New allocations are now done on new pages instead of old ones. The old pages that have been frozen are blue and new pages containing a sequence number are gray.
    \item The GC has finished the marking phase and now have liveness data that indicate where live objects are allocated inside pages.
\end{enumerate}

\vspace*{-0.4cm}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{.214\textwidth}
        \centering
        \includesvg[width=1\textwidth]{figures/zrel1.svg}
        \caption{Initial state of the heap before the first GC cycle.}
        \label{fig:zrel1}
    \end{subfigure}
    \hfill\vline\hfill
    \begin{subfigure}[t]{.32\textwidth}
        \centering
        \includesvg[width=1\textwidth]{figures/zrel2.svg}
        \caption{The state of the heap after marking has started.}
        \label{fig:zrel2}
    \end{subfigure}
    \hfill\vline\hfill
    \begin{subfigure}[t]{.32\textwidth}
        \centering
        \includesvg[width=1\textwidth]{figures/zrel3.svg}
        \caption{The state of the heap after all live objects are marked.}
        \label{fig:zrel3}
    \end{subfigure}
    \caption{Timeline of a garbage collection cycle, showing the state of the heap in the different phases.}
    \label{fig:zgc_timeline}
\end{figure}

\vspace*{-0.49cm}

ZGC frees memory marked as garbage by copying live objects from one page to another and re-purposing the source page for new allocations. This leads to the fragmented layout of allocated memory to be compacted which makes it possible to fit objects from multiple pages into a single one. The process of copying live objects is referred to as relocation. When performing relocation, there are two different scenarios that can occur. The first scenario, where a successful relocation is done by copying items to a new page, is illustrated in Figure~\ref{fig:zrel_new}. This type of relocation requires the heap to have enough free space available to create a new page during the time of relocation. Figure~\ref*{fig:zrel_new1} shows a newly created page, and in Figure~\ref*{fig:zrel_new3}, the old page is freed from memory. The total amount of memory is not decreased, but results in a compacted layout with minimal fragmentation.

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \includesvg[width=1\textwidth,height=1.2885\textwidth]{figures/zrel_new1.svg}
        \caption{A page has been selected for relocation due to high fragmentation.}
        \label{fig:zrel_new1}
    \end{subfigure}
    \hfill\vline\hfill
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \includesvg[width=1\textwidth]{figures/zrel_new2.svg}
        \caption{A new page is created with a new sequence number that is used as a relocation target.}
        \label{fig:zrel_new2}
    \end{subfigure}
    \hfill\vline\hfill
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \includesvg[width=1\textwidth]{figures/zrel_new3.svg}
        \caption{The objects from the first page are relocated to the new page.}
        \label{fig:zrel_new3}
    \end{subfigure}
    \hfill\vline\hfill
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \includesvg[width=1\textwidth]{figures/zrel_new4}
        \caption{All objects have been copied to the new page and the old page is re-purposed.}
        \label{fig:zrel_new3}
    \end{subfigure}
    \caption{An example of how a successful relocation is done when the heap has enough space to allocate a new page.}
    \label{fig:zrel_new}
\end{figure}

In the previous example, relocation was successful in allocating a new page to relocate objects into. If the heap does not have enough space for a new page, the GC will instead resort to performing an in-place compaction. An in-place compaction is an expensive operation re-arranges the objects of a page without a separate page as a destination. It requires the thread performing the re-arrangement to write to the memory of the page while other threads may read its contents. To do this safely, any threads trying to read from the page during this process must be paused, which removes concurrent execution of the page. The process of in-place compaction of a page is illustrated in Figure~\ref{fig:zrel_in}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \includesvg[width=1\textwidth,height=1.2885\textwidth]{figures/zrel_in1.svg}
        \caption{The first live object in the page is moved to the start of the page.}
        \label{fig:zrel_in1}
    \end{subfigure}
    \hfill\vline\hfill
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \includesvg[width=1\textwidth,height=1.2885\textwidth]{figures/zrel_in2.svg}
        \caption{The second live objects is moved as close to the start as possible.}
        \label{fig:zrel_in1}
    \end{subfigure}
    \hfill\vline\hfill
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \includesvg[width=1\textwidth,height=1.2885\textwidth]{figures/zrel_in3.svg}
        \caption{All objects have been moved, and the space after is made available.}
        \label{fig:zrel_in1}
    \end{subfigure}
    \hfill\vline\hfill
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \includesvg[width=1\textwidth,height=1.2885\textwidth]{figures/zrel_in4.svg}
        \caption{The bump pointer is moved to the beginning of available space.}
        \label{fig:zrel_in1}
    \end{subfigure}
    \caption{An example of how in-place compaction is done to remove fragmentation.}
    \label{fig:zrel_in}
\end{figure}
 
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
