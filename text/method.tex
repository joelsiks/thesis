
The methodology is divided into four distinct phases:

\begin{enumerate}
    \item Implement a reference version of an allocator and verify its functionality.
    \item Identify important aspects for memory allocation in garbage collection.
    \item Adapt the reference version with regard to aspects from previous step.
    \item Evaluate the adaptations and how they compare to the reference version.
\end{enumerate}

The initial step involves implementing a reference version of the TLSF memory allocator, that can be used as a starting ground for adaptations. Additionally, having a reference implementation helps in assessing the impacts of modifications more accurately. The functionality of the reference implementation is verified using real-world programs, which entails substituting \texttt{malloc()} and \texttt{free()} with a wrapper that utilizes the reference version of the allocator. The method employed for substitution utilizes the \texttt{LD\_PRELOAD} environment variable in Linux, which enables the preloading of shared libraries prior to system libraries, which allows us to use our allocator instead of the one provided by the system. The set of specific programs that will be used for verification are commonly used Linux-programs: ls, nano, htop and vim. The reference version is considered working if it successfully manages to allocate memory for these programs and does not crash during runtime. 

The next step is identifying important aspects related to memory allocation within the context of garbage collection. This is essential for making informed decisions during the adaptation process. By identifying key aspects related to memory allocation within the context of garbage collection, we are able to gain insight into areas where improvements are likely to have the most significant impact, and are thus most valuable in spending time on. Finding aspects will mainly be done through literature review in the area of memory allocation and garbage collection, as well as insights about ZGC and general memory usage patterns in Java programs. The findings from this step will answer what boundaries are present in the context of allocating memory in ZGC.

Building upon the insights gained from the previous step, the reference implementation is adapted in areas which are likely to be beneficial for both performance and memory efficiency. The adaptation process is conducted incrementally, with each modification being tested through unit tests to ensure that the allocator behaves as intended in every step, which helps in ensuring that adaptations are purposeful and aligned with the research objectives. 

Finally, both the reference implementation and its adapted version(s) will be compared in terms of their performance and memory efficiency. This along with the adaptations that are made to the allocator will answer the second research question. More on specific metrics, evaluation method and steps to reproduce in Section~\ref{sec:evaluation}.

% This will answer the third and last research question on how the adaptations affect the performance and memory efficiency of the allocator. 

% This along with the previous step will help answer both the first and second research questions on what adaptations can be made and what their implications are.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
