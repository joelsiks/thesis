
The methodology is divided into four distinct phases:

\begin{enumerate}
    \item Implement a reference version of an allocator and verify its correctness to use as a starting ground for adaptations.
    \item Identify important aspects for memory allocation in garbage collection to make impactful adaptations to the reference allocator.
    \item Adapt the reference version with regard to the aspects identified in the previous step.
    \item Evaluate both the reference version and adapted versions of the allocator in terms of fragmentation, memory efficiency and runtime performance measured using wall clock time.
\end{enumerate}

The correctness of the reference implementation is verified using real-world programs by substituting \texttt{malloc()} and \texttt{free()} with a wrapper that utilizes the reference version of the allocator. Substitution is done using the \texttt{LD\_PRELOAD} environment variable in Linux, which enables the preloading of shared libraries prior to system libraries, making it possible to use a different allocator than the one provided by the system. The set of specific programs that will be used for verification are the commonly used Linux-programs: \texttt{cat}, \texttt{grep}, \texttt{ls}, \texttt{nano}, \texttt{sed} and \texttt{wc}. Optimally, it would be better to verify correctness using more programs.

However, extensively testing a memory allocator is both a time and resource intensive process. Instead, making sure the allocator works on this subset of programs is a reasonable compromise as theyr are diverse and commonly used. The same programs are later used to evaluate the reference and adapted versions. The reference version is considered working if it successfully manages to allocate memory for these programs and does not crash during runtime.

The second step is identifying important aspects related to memory allocation in the context of garbage collection. This is essential for making informed decisions during the adaptation process. Identifying key aspects gives insight into areas that are likely to have significant impact, and are thus most valuable in spending time on for the third step. Finding aspects will mainly be done through literature review in the area of memory allocation and garbage collection, as well as insights about ZGC and general memory usage patterns in Java programs. The findings from this step will answer what boundaries are present in the context of allocating memory in ZGC.

In the third step, adaptations are made to the reference implementation based on the findings from the second step. The adaptations are carried out gradually, with each adaptation being tested through unit tests to verify that the allocator operates as intended. This approach ensured that modifications are deliberate and in line with the goal of optimizing the allocator with respect to ZGC.

Finally, in the fourth step, both the reference implementation and its adapted version will be compared in terms of their runtime performance and memory efficiency. This along with the adaptations that are made to the allocator will answer the second research question regarding how the boundaries can be utilized to improve the allocator. More on specific metrics, evaluation method and steps to reproduce in Section~\ref{sec:evaluation}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
