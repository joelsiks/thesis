
Memory management~\cite{gchandbook} is typically categorized into being either manual or automatic. Manual memory management involves explicitly managing memory by the programmer, which is commonly used in low-level languages like C and C++. Automatic memory management is handled automatically by the system, without the need for the programmer to intervene. The most common technique for automatic memory management is garbage collection that automatically tracks liveness of memory and reclaimed unused memory. Languages like Python and Java are examples of programming languages that do this.

Memory is most commonly allocated during runtime of the program as opposed to statically allocating everything in advance, during compilation for example. The process of allocating memory during runtime is referred to as dynamic memory management, which presents a number of challenges for reliably being able to satisfy allocation requests and maintain operational stability over extended periods.

The main challenge with dynamic memory allocation is that an allocation might fail due to memory exhaustion. Exhaustion may arise either due to the program requesting more memory than is available in the system or from the circumstance where free memory is available but cannot be reused. The latter case is sometimes referred to as just wasted memory, but to be precise we will classify it as either internal or external fragmentation~\cite{gchandbook}, which will be discussed further below.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
