
% Link results to research questions. Explain what the experiments tell you about your research questions. If any of the experiments “failed” or did not behave as ex- pected, try to reason about potential explanations and propose additional experiments that could be performed to lead the investigation further.

% Limitations and future work. Describe the limitations of your work, i.e., under what assumptions do your conclusions hold? What potentially relevant aspects were outside the scope of your study? Possibly, suggest avenues for future work building upon your study.

Exhaustive and comprehensive benchmarking of allocators is not feasible, and the performance results should not be interpreted as definitive. The performance benchmarks and results do not necessarily indicate how Java-programs will perform when using the allocator in ZGC. Applying patterns instead of using the allocators directly inside programs is also not optimal as it does not show how the allocators behave in practice. For example, without program logic mixed in between allocations and frees, the cache-locality is not fully representative, which might impact performance and thus the reliability of the results. With these considerations in mind, the benchmarks do however compare the allocators on a level which is fairly defined, allowing us to reason about their relative performance. 

From the results we can conclude that the optimized version is somewhat slower and differs in performance of about 12\% on average from the reference version, when applying patterns from a selection of real-world programs. 

When performing single allocations, the optimized version is on-par with the reference version, but is slower than the reference version for single frees.


For single-allocation performance, the optimized version is on-par with the reference version, which is unexpected if the optimized version is slower when performing multiple allocations in combination with frees. A reason for this might be the different block header designs, making it faster to re-use blocks in the reference version. This is something that needs further investigation to draw definitive conclusions about.
% TODO: End this paragraph

The largest adaptation made to the allocator is the concept of the 0-byte header. The 0-byte header stores no information inside allocated blocks, but uses the first 16 bytes of a free block to store metadata, and thus requires the minimum allocation size to be 16, which aligns well with the same limit that ZGC has. The benefit followed by the adaptation, in addition to using less memory, is that allocated memory can be packed more closely together, making more memory fit inside the same cache-line, increasing cache-locality, and likely performance as a result. This is a major benefit that is likely to yield better performance, and is also shared as a goal of the related Lilliput project~\cite{lilliput} in the OpenJDK, which is discussed more, as future work, in Section~\ref{sec:future-work:lilliput}.

Looking at the worst-case for internal fragmentation, we can show that the only source of internal fragmentation for the optimized version is due to padding. Since the optimized version is able to completely remove the block header for allocated blocks, there is practically no memory overhead for allocated blocks apart from padding. This means that the optimized version is no different in terms of internal fragmentation from using bump-pointer allocation, which also applies padding to meet alignment requirements.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
