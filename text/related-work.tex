
% I want to describe that even though allocators have been designed about for a long time, the problem is still not solved.
% Perhaps quote the TLSF paper?

\subsection{Allocators}

DLmalloc~\cite{dlmalloc}, named after its creator Doug Lea, is one of the most cited and widely used memory allocators. It stands out for its use of different policies to select blocks based on the size of the allocation request. In contrast to TLSF, which employs the previously described 'good-fit' policy, DLmalloc utilizes four distinct policies: first-fit, cached blocks, segregated-fits, and OS allocation. This approach aims to optimize average performance across various allocation sizes. However, it often leads to higher worst-case response times or difficulty in defining them compared to TLSF's uniform policy for all allocation sizes.

DLmalloc is considered a general-purpose allocator, meaning it is tailored to work in any kind of environment. However, a common recommendation~\cite{custom_rec_1, custom_rec_2} to improve performance is to take advantage of application-specific knowledge to manage memory more efficiently. This is done in commonly used applications such as the Apache web server and the GCC compiler. In relation to this, R. Jones et al.~\cite{gchandbook} discuss that in the context of garbage collection, customizing allocators for use in a GC have a desirable impact on both performance and memory usage. Much like taking advantage of application-specific knowledge, a memory allocator for a GC might utilize GC-specific behavior to its advantage to achieve these desired effects.

On the topic of custom allocators, D. Berger et al.~\cite{slow_custom_allocators} conducted a survey, revealing that they often match DLmalloc's performance, which contradicts the conventional recommendation of customizing allocators for performance gains. However, their study focuses solely on traditional memory allocation scenarios, potentially limiting its applicability. It is important to recognize that their findings may not directly apply to garbage collection. Garbage collectors possess detailed knowledge about objects being allocated, influencing optimization strategies and performance. For example, a generational garbage collector like ZGC is able to treat objects with varying lifetimes in different ways, which has been shown by D. Barret and B. Zorn~\cite{lifetime_predictors_memalloc} to potentially improve performance and memory efficiency. This might be harder to do in other programs due to the lack of lifetime heuristics, which is something that is not addressed in the work of D. Berger et al. Thus, while valuable, their findings may not fully address the complexities of usage within garbage collection frameworks.

\subsection{Free-Lists in Garbage Collection}

The integration of free-lists into garbage collection is not a recent development but has a longstanding history. In the mark-sweep GC algorithm~\cite{mark_sweep}, the utilization of free-lists becomes essential, particularly due to its non-moving nature where live objects are never moved in the heap, which often results in fragmented memory layouts. Consequently, a free-list provides an efficient mechanism for managing fragmented memory segments, as opposed to expecting a single contiguous block of memory. Conversely, in moving collectors, the memory tends to be organized into a large contiguous chunk post-compaction, making sequential or bump-pointer allocation methods more suitable. Although sequential allocation might be most suitable, it does not rule out the use of free-lists for bookkeeping memory, and is something that will have to be investigated more closely to learn the impacts on both performance and memory usage.

Moreover, among free-list strategies, the segregated-fits variant stands out for its efficiency, as highlighted by R. Jones et al.~\cite[Section 7.8]{gchandbook}. More precisely, segregated-fits outperform other strategies like first-fit or best-fit, which is advantageous for programs garbage collected programs that typically allocate memory more often than programs coded using memory manually.

W. H. Lee and J. Chang~\cite{samsung_gc_free_list} implement a GC for C++ that keeps track of freed objects in a free-list to be able to reuse them later, similar to what is done to keep track of free memory in the mark-sweep GC algorithm. Empirical evaluation show that most objects are small and have short life-spans, which results in many small allocations and frees, making the use of a free-list attractive to improve allocation speeds since blocks can efficiently be reused. Garbage collectors most often free memory in large chunks~\cite[Section 7.8]{gchandbook}, but in cases where freeing single pieces of memory might be considered, a free-list is a natural choice for its potential to fill sparsely populated areas.

In conclusion, free-lists are already used in several places in the context of garbage collectors and certain free-list strategies outperform others. As this work is meant to investigate replacing bump-pointer allocation with free-list allocation, understanding the role and implications of free-lists provides and essential foundation for continuing research in this area.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
